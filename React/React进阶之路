父组件的重新渲染会导致子组件的重新渲染，虽然它的props 和 state 没有改变

重新调用render函数

其中使用生产环境版本的库是项目中必须采用的，使用key也推荐在项目中采用。通过重写shouldComponentUpdate方法避免不必要的组件渲染，

props和state 区别。props对外，state对内

Context当组件所处层级太深时，往往需要经过很多层的props传递才能将所需的数据或者回调函数传递给使用组件。这时，以props作为桥梁的组件通信方式便会显得很烦琐。例如，我们把UserList中新增用户的工作单独拆分到一个新的组件UserAdd中：

同时，箭头函数内的this指向函数定义时所在的上下文对象，而不是函数执行时的上下文对象。

模板字符串是增强版的字符串，用反引号（`）标识字符串。

ES 6允许按照一定模式从数组和对象中提取值，对变量进行赋值，这被称为解构。

NPM是一个模块管理工具，用来管理模块的发布、下载及模块之间的依赖关系。

Webpack是用于现代JavaScript应用程序的模块打包工具。Webpack会递归地构建一个包含应用程序所需的每个模块的依赖关系图，然后将所有模块打包到少量文件中。Webpack不仅可以打包JS文件，配合相关插件的使用，它还可以打包图片资源和样式文件，已经具备一站式的JavaScript应用打包能力。

node_modules文件夹内是安装的所有依赖模块；package.json文件定义了项目的基本信息，如项目名称、版本号、在该项目下可执行的命令以及项目的依赖模块等；

当使用DOM类型的标签时，标签的首字母必须小写；当使用React组件类型的标签时，组件名称的首字母必须大写。React正是通过首字母的大小写判断渲染的是一个DOM类型的标签还是一个React组件类型的标签

，JSX中只能使用JavaScript表达式，而不能使用多行JavaScript语句。

在Diff算法中，比较的两方是新的虚拟DOM和旧的虚拟DOM，而不是虚拟DOM和真实DOM，只不过Diff的结果会更新到真实DOM上。

1．当根节点是不同类型时从div变成p、从ComponentA变成ComponentB，或者从ComponentA变成div，这些都是节点类型发生变化的情况。根节点类型的变化是一个很大的变化，React会认为新的树和旧的树完全不同，不会再继续比较其他属性和子节点，而是把整棵树拆掉重建（包括虚拟DOM树和真实DOM树）。这里需要注意，虚拟DOM的节点类型分为两类：一类是DOM元素类型，比如div、p等；一类是React组件类型，比如自定义的React组件。在旧的虚拟DOM树被拆除的过程中，旧的DOM元素类型的节点会被销毁，旧的React组件实例的componentWillUnmount会被调用；在重建的过程中，新的DOM元素会被插入DOM树中，新的组件实例的componentWillMount和componentDidMount方法会被调用。重建后的新的虚拟DOM树又会被整体更新到真实DOM树中。这种情况下，需要大量DOM操作，更新效率最低。

2．当根节点是相同的DOM元素类型时如果两个根节点是相同类型的DOM元素，React会保留根节点，而比较根节点的属性，然后只更新那些变化了的属性。

3．当根节点是相同的组件类型时如果两个根节点是相同类型的组件，对应的组件实例不会被销毁，只是会执行更新操作，同步变化的属性到虚拟DOM树上，这一过程组件实例的componentWillReceiveProps()和componentWillUpdate()会被调用。注意，对于组件类型的节点，React是无法直接知道如何更新真实DOM树的，需要在组件更新并且render方法执行完成后，根据render返回的虚拟DOM结构决定如何更新真实DOM树。比较完根节点后，React会以同样的原则继续递归比较子节点，每一个子节点相对于其层级以下的节点来说又是一个根节点。如此递归比较，直到比较完两棵树上的所有节点，计算得到最终的差异，更新到DOM树中。

为了解决这种低效的更新方式，React提供了一个key属性。在2.4节已经介绍过，当渲染列表元素时，需要为每一个元素定义一个key。这个key就是为了帮助React提高Diff算法的效率。当一组子节点定义了key，React会根据key来匹配子节点，在每次渲染之后，只要子节点的key值没有变化，React就认为这是同一个节点。例

React只需要执行一次插入新节点的操作。这里同时揭露了另一个问题，尽量不要使用元素在列表中的索引值作为key，因为列表中的元素顺序一旦发生改变，就可能导致大量的key失效，进而引起大量的修改操作。例如，下面的写法应该尽量避免

只需要执行npm run build，就会构建生产环境版本的React库。

当组件的props或state发生变化时，组件的render方法会被重新调用，返回一个新的虚拟DOM对象。但在一些情况下，组件是没有必要重新调用render方法的。例如，父组件的每一次render调用都会触发子组件componentWillReceiveProps的调用，进而子组件的render方法也会被调用，但是这时候子组件的props可能并没有发生改变，改变的只是父组件的props或state，所以这一次子组件的render是没有必要的，不仅多了一次render方法执行的时间，还多了一次虚拟DOM比较的时间。React组件的生命周期方法中提供了一个shouldComponentUpdate方法，这个方法的默认返回值是true，如果返回false，组件此次的更新将会停止，也就是后续的componentWillUpdate、render等方法都不会再被执行。

Component作为所有组件的基类，提供了很多组件共有的功能，

这个错误信息的含义是：“在使用JSX的范围内必须要有React。”也就是说，在使用JSX的代码文件中，即使代码中并没有直接使用React，也一定要导入这个React，这是因为JSX最终会被转译成依赖于React的表达式

细心的读者会发现，虽然我们导入的Component类在ClickCounter组件定义中使用了，可是导入的React却没有被使用，难道在这里引入React没有必要吗？

React判断一个元素是HTML元素还是React组件的原则就是看第一个字母是否大写，如果在JSX中我们不用ClickCounter而是用clickCounter，那就得不到我们想要的结果。

在jQuery的解决方案中，首先根据CSS规则找到id为clickCount的按钮，挂上一个匿名事件处理函数，在事件处理函数中，选中那个需要被修改的DOM元素，读取其中的文本值，加以修改，然后修改这个DOM元素。

对于开发者来说，重要的是区分开哪些属于data，哪些属于render，想要更新用户界面，要做的就是更新data，用户界面自然会做出响应，所以React实践的也是“响应式编程”（Reactive Programming）的思想，这也就是React为什么叫做React的原因。

拆分组件最关键的就是确定组件的边界，每个组件都应该是可以独立存在的，如果两个组件逻辑太紧密，无法清晰定义各自的责任，那也许这两个组件本身就不该被拆开，作为同一个组件也许更合理。虽然组件是应该独立存在的，但是并不是说组件就是孤岛一样的存在，不同组件之间总是会有通信交流，这样才可能组合起来完成更大的功能。

高内聚指的是把逻辑紧密相关的内容放在一个组件中。用户界面无外乎内容、交互行为和样式。传统上，内容由HTML表示，交互行放在JavaScript代码文件中，样式放在CSS文件中定义。这虽然满足一个功能模块的需要，却要放在三个不同的文件中，这其实不满足高内聚的原则。React却不是这样，展示内容的JSX、定义行为的JavaScript代码，甚至定义样式的CSS，都可以放在一个JavaScript文件中，因为它们本来就是为了实现一个目的而存在的，所以说React天生具有高内聚的特点。低耦合指的是不同组件之间的依赖关系要尽量弱化，也就是每个组件要尽量独立。保持整个系统的低耦合度，需要对系统中的功能有充分的认识，然后根据功能点划分模块，让不同的组件去实现不同的功能，这个功夫还在开发者身上，不过，React组件的对外接口非常规范，方便开发者设计低耦合的系统。

React组件的数据分为两种，prop和state，无论prop或者state的改变，都可能引发组件的重新渲染，那么，设计一个组件的时候，什么时候选择用prop什么时候选择用state呢？其实原则很简单，prop是组件的对外接口，state是组件的内部状态，对外用prop，内部用state。

我们先从外部世界来看，prop是如何使用的，在下面的JSX代码片段中，就使用了prop：[插图]在上面的例子中，创建了名为SampleButton的组件实例，使用了名字分别为id、border Width、onClick和style的prop，看起来，React组件的prop很像是HTML元素的属性，不过，HTML组件属性的值都是字符串类型，即使是内嵌JavaScript，也依然是字符串形式表示代码。React组件的prop所能支持的类型则丰富得多，除了字符串，可以是任何一种JavaScript语言支持的数据类型。

`<SampleButton
id="sample" borderWidth={2} onClick={onButtonClick}
style={{color: "red"}}
/>`

style的值是一个包含color字段的对象，当prop的类型不是字符串类型时，在JSX中必须用花括号{}把prop值包住，所以style的值有两层花括号，外层花括号代表是JSX的语法，内层的花括号代表这是一个对象常量

同样，React组件要反馈数据给外部世界，也可以用prop，因为prop的类型不限于纯数据，也可以是函数，函数类型的prop等于让父组件交给了子组件一个回调函数，子组件在恰当的实际调用函数类型的prop，可以带上必要的参数，这样就可以反过来把信息传递给外部世界。

propTypes虽然能够在开发阶段发现代码中的问题，但是放在产品环境中就不大合适了。首先，定义类的propTypes属性，无疑是要占用一些代码空间，而且propTypes检查也是要消耗CPU计算资源的。其次，在产品环境下做propTypes检查没有什么帮助，毕竟，propTypes产生的这些错误信息只有开发者才能看得懂，放在产品环境下，在最终用户的浏览器Console中输出这些错误信息没什么意义。

所以，最好的方式是，开发者在代码中定义propTypes，在开发过程中避免犯错，但是在发布产品代码时，用一种自动的方式将propTypes去掉，这样最终部署到产品环境的代码就会更优。现有的babel-react-optimize就具有这个功能，可以通过npm安装，但是应该确保只在发布产品代码时使用它。

总结一下prop和state的区别：□ prop用于定义外部接口，state用于记录内部状态；□ prop的赋值在外部世界使用组件时，state的赋值在组件内部；□ 组件不应该改变prop的值，而state存在的目的就是让组件来改变的。

但是，组件是绝不应该去修改传入的props值的，我们设想一下，假如父组件包含多个子组件，然后把一个JavaScript对象作为props值传给这几个子组件，而某个子组件居然改变了这个对象的内部值，那么，接下来其他子组件读取这个对象会得到什么值呢？当时读取了修改过的值，但是其他子组件是每次渲染都读取这个props的值呢？还是只读一次以后就用那个最初值呢？一切皆有可能，完全不可预料。也就是说，一个子组件去修改props中的值，可能让程序陷入一团混乱之中，这就完全违背了React设计的初衷。还记得第1章中我们看到的那个公式吗？UI=render(data)React组件扮演的是render函数的角色，应该是一个没有副作用的纯函数。修改props的值，是一个副作用，组件应该避免。

组件的生命周期为了理解React的工作过程，我们就必须要了解React组件的生命周期，如同人有生老病死，自然界有日月更替，每个组件在网页中也会被创建、更新和删除，如同有生命的机体一样。React严格定义了组件的生命周期，生命周期可能会经历如下三个过程：□ 装载过程（Mount），也就是把组件第一次在DOM树中渲染的过程；□ 更新过程（Update），当组件被重新渲染的过程；□ 卸载过程（Unmount），组件从DOM中删除的过程。三种不同的过程，React库会依次调用组件的一些成员函数，这些函数称为生命周期函数。所以，要定制一个React组件，实际上就是定制这些生命周期函数

1. constructor我们先来看第一个constructor，也就是ES6中每个类的构造函数，要创造一个组件类的实例，当然会调用对应的构造函数。要注意，并不是每个组件都需要定义自己的构造函数。在后面的章节我们可以看到，无状态的React组件往往就不需要定义构造函数，一个React组件需要构造函数，往往是为了下面的目的：□ 初始化state，因为组件生命周期中任何函数都可能要访问state，那么整个生命周期中第一个被调用的构造函数自然是初始化state最理想的地方；□ 绑定成员函数的this环境。

render函数无疑是React组件中最重要的函数，一个React组件可以忽略其他所有函数都不实现，但是一定要实现render函数，因为所有React组件的父类React.Component类对除render之外的生命周期函数都有默认实现。通常一个组件要发挥作用，总是要渲染一些东西，render函数并不做实际的渲染动作，它只是返回一个JSX描述的结构，最终由React来操作渲染过程。

当然，某些特殊组件的作用不是渲染界面，或者，组件在某些情况下选择没有东西可画，那就让render函数返回一个null或者false，等于告诉React，这个组件这次不需要渲染任何DOM元素。

需要注意，render函数应该是一个纯函数，完全根据this.state和this.props来决定返回的结果，而且不要产生任何副作用。在render函数中去调用this.setState毫无疑问是错误的，因为一个纯函数不应该引起状态的改变。我们在后面的章节会对render函数做详细的介绍。

在装载过程中，componentWillMount会在调用render函数之前被调用，component-DidMount会在调用render函数之后被调用，这两个函数就像是render函数的前哨和后卫，一前一后，把render函数夹住，正好分别做render前后必要的工作。不过，我们通常不用定义componentWillMount函数，顾名思义，componentWillMount发生在“将要装载”的时候，这个时候没有任何渲染出来的结果，即使调用this.setState修改状态也不会引发重新绘制，一切都迟了。换句话说，所有可以在这个component-WillMount中做的事情，都可以提前到constructor中间去做，可以认为这个函数存在的主要目的就是为了和componentDidMount对称。

而componentWillMount的这个兄弟componentDidMount作用就大了。需要注意的是，render函数被调用完之后，componentDidMount函数并不是会被立刻调用，componentDidMount被调用的时候，render函数返回的东西已经引发了渲染，组件已经被“装载”到了DOM树上。

，是因为render函数本身并不往DOM树上渲染或者装载内容，它只是返回一个JSX表示的对象，然后由React库来根据返回对象决定如何渲染。而React库肯定是要把所有组件返回的结果综合起来，才能知道该如何产生对应的DOM修改。所以，只有React库调用三个Counter组件的render函数之后，才有可能完成装载，这时候才会依次调用各个组件的componentDidMount函数作为装载过程的收尾。componentWillMount和componentDidMount这对兄弟函数还有一个区别，就是component-WillMount可以在服务器端被调用，也可以在浏览器端被调用；而component-DidMount只能在浏览器端被调用，在服务器端使用React的时候不会被调用。更新过程会依次调用下面的生命周期函数，其中render函数和装载过程一样，没有差别。□ componentWillReceiveProps□ shouldComponentUpdate□ componentWillUpdate□ render□ componentDidUpdate有意思的是，并不是所有的更新过程都会执行全部函数，

实际上，只要是父组件的render函数被调用，在render函数里面被渲染的子组件就会经历更新过程，不管父组件传给子组件的props有没有改变，都会触发子组件的componentWill-ReceiveProps函数。

除了在ControlPanel的render函数入口处增加console输出，我们还增加了一个按钮，这个按钮的onClick事件引发一个匿名函数，当这个按钮被点击的时候，调用this. forceUpdate，每个React组件都可以通过forceUpdate函数强行引发一次重新绘制。

注意类似上面的代码，在JSX用直接把匿名函数赋值给onClick的方法，看起来非常简洁而且方便，其实并不是值得提倡的方法。因为每次渲染都会创造一个新的匿名方法对象，而且有可能引发子组件不必要的重新渲染，原因在后面的章节会有详细介绍。

在更新过程中，React库首先调用shouldComponentUpdate函数，如果这个函数返回true，那就会继续更新过程，接下来调用render函数；反之，如果得到一个false，那就立刻停止更新过程，也就不会引发后续的渲染了。